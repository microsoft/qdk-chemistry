# Coverage pipeline for QDK/Chemistry
#
# Required Azure Pipeline Secure Files:
# - github-ssh-key: SSH private key for pushing documentation to GitHub Pages repository

trigger:
  branches:
    include:
    - main

# Trigger this pipeline on PRs targeting any branch
pr:
  branches:
    include:
    - '*'
  drafts: true

parameters:
- name: march
  displayName: Micro Architecture
  default: native
  type: string
  values:
  - znver2
  - znver3
  - skylake-avx512
  - x86-64-v3
  - native

- name: cpuPool
  displayName: The pool to use for CPU only jobs
  type: string
- name: gpuPool
  displayName: The pool to use for GPU jobs
  type: string
- name: artifactOrganization
  displayName: Azure DevOps Organization URL
  type: string
- name: artifactProject
  displayName: Azure DevOps Project ID
  type: string
- name: artifactFeed
  displayName: Azure Artifacts Feed Name
  type: string

resources:
  repositories:
  - repository: self
    path: qdk-chemistry

variables:
  date: $[format('{0:yyyy}.{0:MM}.{0:dd}', pipeline.startTime)]
  ${{ if eq(parameters.march, 'x86-64-v3') }}:  # -march=x86-64-v3 flag not supported by GCC < 12
    march: x86-64
  ${{ else }}:
    march: ${{ parameters.march }}

stages:
- stage: Coverage
  displayName: Coverage
  jobs:
  - job: Coverage
    displayName: Coverage
    pool: ${{ parameters.cpuPool }}
    timeoutInMinutes: 240
    variables:
      LD_LIBRARY_PATH: $LD_LIBRARY_PATH:/usr/local/lib
    steps:
    - task: UsePythonVersion@0
      inputs:
        versionSpec: '3.13'
      displayName: Use Python 3.13

    - template: templates/non-docker-build.yml
      parameters:
        march: ${{ variables.march }}
        buildType: Debug
        enableCoverage: ON
        buildTesting: ON
        agentBuildDirectory: $(Agent.BuildDirectory)
        systemDefaultWorkingDirectory: $(System.DefaultWorkingDirectory)
        artifactProject: ${{ parameters.artifactProject }}
        artifactFeed: ${{ parameters.artifactFeed }}

    # C++ Tests with Coverage
    - script: |
        mkdir -p $(System.DefaultWorkingDirectory)/test-results
        cd $(Agent.BuildDirectory)/qdk-chemistry/build_cpp/tests

        # Initialize test result tracking
        FAILED_TESTS=()
        TOTAL_TESTS=0
        PASSED_TESTS=0

        echo "=== Running C++ Tests ==="
        for test_exe in test_*; do
          if [ -x "$test_exe" ] && [ -f "$test_exe" ]; then
            TOTAL_TESTS=$((TOTAL_TESTS + 1))
            echo "Running $test_exe with XML output..."

            # Run test with timeout and capture exit code
            set +e
            timeout 300 ./"$test_exe" --gtest_output=xml:$(System.DefaultWorkingDirectory)/test-results/"$test_exe"_results.xml
            EXIT_CODE=$?
            set -e

            # Check for various failure conditions
            if [ $EXIT_CODE -ne 0 ]; then
              echo "ERROR: Test $test_exe failed with exit code $EXIT_CODE"

              # Check for specific error types
              case $EXIT_CODE in
                139)
                  echo "CRITICAL: Test $test_exe crashed with SEGFAULT (SIGSEGV)"
                  ;;
                134|6)
                  echo "CRITICAL: Test $test_exe crashed with SIGABRT (assertion failure or abort)"
                  ;;
                124)
                  echo "CRITICAL: Test $test_exe timed out after 300 seconds"
                  ;;
                *)
                  echo "CRITICAL: Test $test_exe failed with exit code $EXIT_CODE"
                  ;;
              esac

              FAILED_TESTS+=("$test_exe (exit code: $EXIT_CODE)")
            else
              echo "SUCCESS: Test $test_exe passed"
              PASSED_TESTS=$((PASSED_TESTS + 1))
            fi
            echo "----------------------------------------"
          fi
        done

        echo "=== C++ Test Summary ==="
        echo "Total tests: $TOTAL_TESTS"
        echo "Passed tests: $PASSED_TESTS"
        echo "Failed tests: ${#FAILED_TESTS[@]}"

        if [ ${#FAILED_TESTS[@]} -gt 0 ]; then
          echo "=== FAILED TESTS ==="
          for failed_test in "${FAILED_TESTS[@]}"; do
            echo "  - $failed_test"
          done
          echo "=== C++ TESTS FAILED - PIPELINE WILL FAIL ==="
        fi

        mkdir -p $(System.DefaultWorkingDirectory)/coverage-reports
        gcovr --root $(Agent.BuildDirectory)/qdk-chemistry/cpp --object-directory $(Agent.BuildDirectory)/qdk-chemistry/build_cpp --exclude '.*/tests/.*' --exclude '.*test.*\.cpp' --exclude '.*gtest.*' --exclude '.*gmock.*' --html-details $(System.DefaultWorkingDirectory)/coverage-reports/cpp_coverage.html --xml $(System.DefaultWorkingDirectory)/coverage-reports/cpp_coverage.xml --txt $(System.DefaultWorkingDirectory)/coverage-reports/cpp_coverage.txt
        echo "Coverage Summary:"
        cat $(System.DefaultWorkingDirectory)/coverage-reports/cpp_coverage.txt

        # Exit with failure if any tests failed
        if [ ${#FAILED_TESTS[@]} -gt 0 ]; then
          exit 1
        fi
      displayName: Run C++ Tests with XML Output

    # Python Tests with Coverage
    - script: |
        mkdir -p $(System.DefaultWorkingDirectory)/test-results
        cd $(Agent.BuildDirectory)/qdk-chemistry/python

        # The build directory will be something like build/cp313-cp313-linux_x86_64
        BUILD_TEMP=$(find . -type d -path "./build/cp*" | head -1)

        echo "Found build directory: $BUILD_TEMP"
        echo "$BUILD_TEMP" > build_temp_path.txt
        echo "Saved build temp path to file: $(cat build_temp_path.txt)"

        # Read BUILD_TEMP from the file written in the previous step
        if [ -f "build_temp_path.txt" ]; then
            BUILD_TEMP=$(cat build_temp_path.txt)
            echo "Read build temp directory from file: $BUILD_TEMP"
        else
            echo "Warning: build_temp_path.txt not found"
            BUILD_TEMP=""
        fi

        # Run coverage with explicit source specification
        echo "=== Running Coverage ==="
        echo "Coverage version: $(python3 -m coverage --version)"

        # Remove any existing coverage data
        rm -f .coverage*

        # Try using pytest-cov as alternative approach with proper error handling
        echo "Coverage with pytest-cov..."

        # Run pytest with explicit error handling
        set +e
        python3 -m pytest \
          --cov=src \
          --cov-report=xml:$(System.DefaultWorkingDirectory)/coverage-reports/python_coverage.xml \
          --cov-report=html:$(System.DefaultWorkingDirectory)/coverage-reports/python_coverage_html \
          --cov-report=term \
          --junitxml=$(System.DefaultWorkingDirectory)/test-results/pytest_report.xml \
          -v \
          --tb=short \
          > $(System.DefaultWorkingDirectory)/coverage-reports/python_coverage.txt 2>&1

        PYTEST_EXIT_CODE=$?
        set -e

        # Display the output
        echo "=== Python Test Output ==="
        cat $(System.DefaultWorkingDirectory)/coverage-reports/python_coverage.txt
        echo "=========================="

        # Check pytest exit code and handle different failure types
        if [ $PYTEST_EXIT_CODE -ne 0 ]; then
          echo "ERROR: Python tests failed with exit code $PYTEST_EXIT_CODE"

          # Analyze exit codes (pytest exit codes)
          case $PYTEST_EXIT_CODE in
            1)
              echo "CRITICAL: Tests failed - some test failures occurred"
              ;;
            2)
              echo "CRITICAL: Tests were interrupted by the user"
              ;;
            3)
              echo "CRITICAL: Internal error occurred during test execution"
              ;;
            4)
              echo "CRITICAL: pytest command line usage error"
              ;;
            5)
              echo "CRITICAL: No tests were collected"
              ;;
            139)
              echo "CRITICAL: Python tests crashed with SEGFAULT"
              ;;
            134|6)
              echo "CRITICAL: Python tests crashed with SIGABRT"
              ;;
            *)
              echo "CRITICAL: Python tests failed with unknown exit code $PYTEST_EXIT_CODE"
              ;;
          esac

          # Check for segfaults or crashes in the output
          if grep -qi "segmentation fault\|segfault\|sigsegv" $(System.DefaultWorkingDirectory)/coverage-reports/python_coverage.txt; then
            echo "CRITICAL: Segmentation fault detected in Python test output"
          fi

          if grep -qi "fatal error\|abort\|assertion.*failed" $(System.DefaultWorkingDirectory)/coverage-reports/python_coverage.txt; then
            echo "CRITICAL: Fatal error or assertion failure detected in Python test output"
          fi

          echo "=== PYTHON TESTS FAILED - PIPELINE WILL FAIL ==="
        else
          echo "Python tests completed successfully!"
        fi

        # After tests run, copy .gcda files from temp directory if it still exists
        if [ -n "$BUILD_TEMP" ] && [ -d "$BUILD_TEMP" ]; then
            echo "=== Copying .gcda files from temp directory ==="
            find "$BUILD_TEMP" -name "*.gcda" -exec cp {} coverage_build/ \; 2>/dev/null || true
            echo "Copied .gcda files to coverage_build/"
        fi

        echo "Python Coverage Summary:"
        if [ -f "$(System.DefaultWorkingDirectory)/coverage-reports/python_coverage.txt" ]; then
          # Extract just the coverage summary to avoid too much output
          tail -20 $(System.DefaultWorkingDirectory)/coverage-reports/python_coverage.txt
        fi

        # Exit with failure if pytest failed
        if [ $PYTEST_EXIT_CODE -ne 0 ]; then
          exit 1
        fi
      displayName: Run Python Tests then Generate Python Coverage

    - script: |
        cd $(Agent.BuildDirectory)/qdk-chemistry/python

        echo "=== Looking for pybind11 coverage files ==="
        PYBIND_BUILD_DIR=$(find . -wholename "./build/cp*/CMakeFiles/_core.dir" | head -1)

        if [ -n "$PYBIND_BUILD_DIR" ]; then
            echo "Found pybind11 build directory: $PYBIND_BUILD_DIR"

            # Check for coverage files
            GCNO_COUNT=$(find "$PYBIND_BUILD_DIR" -name "*.gcno" | wc -l)
            GCDA_COUNT=$(find "$PYBIND_BUILD_DIR" -name "*.gcda" | wc -l)

            echo "Found $GCNO_COUNT .gcno files and $GCDA_COUNT .gcda files"

            if [ "$GCNO_COUNT" -gt 0 ]; then
                # Set paths for gcovr
                PYTHON_ROOT="$(Agent.BuildDirectory)/qdk-chemistry/python"
                CLEAN_BUILD_DIR="${PYBIND_BUILD_DIR#./}"
                OBJECT_DIR="$(Agent.BuildDirectory)/qdk-chemistry/python/${CLEAN_BUILD_DIR}"

                echo "=== Coverage Generation Settings ==="
                echo "Python root: $PYTHON_ROOT"
                echo "Object directory: $OBJECT_DIR"

                # Show some sample files for debugging
                echo "Sample coverage files:"
                find "$PYBIND_BUILD_DIR" -name "*.gcno" | head -3
                find "$PYBIND_BUILD_DIR" -name "*.gcda" | head -3

                # Generate coverage report
                gcovr \
                  --root "$PYTHON_ROOT" \
                  --object-directory "$OBJECT_DIR" \
                  --filter '.*src/pybind11.*' \
                  --filter '.*src/cpp.*' \
                  --exclude '.*test.*' \
                  --exclude '.*external.*' \
                  --gcov-ignore-errors=no_working_dir_found \
                  --gcov-ignore-errors=source_not_found \
                  --verbose \
                  --xml "$(System.DefaultWorkingDirectory)/coverage-reports/pybind11_coverage.xml" \
                  --txt "$(System.DefaultWorkingDirectory)/coverage-reports/pybind11_coverage.txt" \
                  --html-details "$(System.DefaultWorkingDirectory)/coverage-reports/pybind11_coverage.html"

                echo "Pybind11 Coverage Summary:"
                if [ -f "$(System.DefaultWorkingDirectory)/coverage-reports/pybind11_coverage.txt" ]; then
                  cat $(System.DefaultWorkingDirectory)/coverage-reports/pybind11_coverage.txt
                else
                  echo "Pybind11 coverage report not generated"
                fi
            else
                echo "ERROR: No .gcno files found - coverage was not enabled during build"
            fi
        else
            echo "ERROR: Could not find pybind11 build directory"
            echo "Available build directories:"
            find . -type d -name "build" -o -name "cp*" | head -5
        fi
      displayName: Generate Pybind11 C++ Coverage

    - task: PublishCodeCoverageResults@2
      inputs:
        summaryFileLocation: $(System.DefaultWorkingDirectory)/coverage-reports/*.xml
        pathToSources: $(System.DefaultWorkingDirectory)
      displayName: Publish Combined Coverage Reports

    - task: PublishTestResults@2
      inputs:
        testResultsFormat: JUnit
        testResultsFiles: $(System.DefaultWorkingDirectory)/test-results/*.xml
        testRunTitle: QDK/Chemistry Tests
        mergeTestResults: true
        failTaskOnFailedTests: true
      displayName: Publish Test Results

#    # Documentation tasks
#    - script: |
#        cd $(Agent.BuildDirectory)/qdk-chemistry/python
#        pip install -e .[docs,plugins] --verbose
#        # Install additional documentation dependencies not in pyproject.toml
#        pip install breathe numpydoc sphinx-autodoc-typehints
#      displayName: Install Documentation Dependencies
#
#    - script: |
#        cd $(Agent.BuildDirectory)/qdk-chemistry/docs
#        python generate_docs.py --clean
#      displayName: Generate Sphinx Documentation
#
#    - script: |
#        cd $(Agent.BuildDirectory)/qdk-chemistry/docs/build
#
#        # Validate that documentation was built successfully
#        if [ ! -d "html" ]; then
#          echo "ERROR: HTML directory not found"
#          exit 1
#        fi
#
#        if [ ! -f "html/index.html" ]; then
#          echo "ERROR: index.html not found"
#          exit 1
#        fi
#
#        # Check for common documentation files
#        echo "Documentation structure:"
#        find html -name "*.html" | head -10
#
#        # Check file sizes to ensure content was generated
#        HTML_SIZE=$(du -sh html | cut -f1)
#        echo "Documentation size: $HTML_SIZE"
#
#        # Count HTML files
#        HTML_COUNT=$(find html -name "*.html" | wc -l)
#        echo "Number of HTML files: $HTML_COUNT"
#
#        if [ "$HTML_COUNT" -lt 5 ]; then
#          echo "WARNING: Very few HTML files generated ($HTML_COUNT), documentation may be incomplete"
#        fi
#      displayName: Validate Documentation Build
#
#    - task: PublishBuildArtifacts@1
#      inputs:
#        pathtoPublish: $(Agent.BuildDirectory)/qdk-chemistry/docs/build/html
#        artifactName: qdk-chemistry-documentation
#        publishLocation: Container
#      displayName: Publish Documentation as Artifact
#      condition: eq(variables['Build.SourceBranch'], 'refs/heads/main')
#
#    - task: DownloadSecureFile@1
#      name: githubSshKey
#      displayName: 'Download GitHub SSH Key'
#      inputs:
#        secureFile: 'qdk_chemistry_github_deployment_ssh_pk'
#
#    - script: |
#        # Check if deployment should be skipped
#        if [ "${{ parameters.skipDocsDeployment }}" = "true" ]; then
#          echo "Documentation deployment to Git repository is disabled via pipeline parameter"
#          echo "Documentation is still available as a pipeline artifact"
#          exit 0
#        fi
#
#        cd $(Agent.BuildDirectory)/qdk-chemistry/docs/build
#
#        # Check if documentation was built successfully
#        if [ ! -d "html" ] || [ ! -f "html/index.html" ]; then
#          echo "ERROR: Documentation build failed or HTML directory not found"
#          exit 1
#        fi
#
#        echo "Documentation built successfully. Contents of html directory:"
#        ls -la html/
#
#        # Configure SSH key for GitHub authentication (for documentation deployment)
#        echo "Setting up SSH authentication for GitHub documentation deployment..."
#        mkdir -p ~/.ssh
#        cp $(githubSshKey.secureFilePath) ~/.ssh/id_rsa
#        chmod 600 ~/.ssh/id_rsa
#        ssh-keyscan github.com >> ~/.ssh/known_hosts
#        eval "$(ssh-agent -s)"
#        ssh-add ~/.ssh/id_rsa
#
#        # Configure git for the documentation push
#        git config --global user.email "azure-pipelines@microsoft.com"
#        git config --global user.name "Azure Pipelines Documentation Bot"
#
#        # Create a temporary directory for the documentation repository
#        DOC_REPO_DIR="$(mktemp -d)"
#        echo "Using temporary directory: $DOC_REPO_DIR"
#
#        # Clone the documentation repository
#        echo "Cloning documentation repository from: ${{ parameters.docsRepository }}"
#        if ! git clone --depth 1 --branch ${{ parameters.docsBranch }} "${{ parameters.docsRepository }}" "$DOC_REPO_DIR"; then
#          echo "ERROR: Failed to clone documentation repository"
#          echo "Please ensure the repository exists and SSH key has proper access"
#          exit 1
#        fi
#
#        cd "$DOC_REPO_DIR"
#
#        # Remove old docs folder if it exists
#        if [ -d "docs" ]; then
#          echo "Removing existing docs folder..."
#          rm -rf docs
#        fi
#
#        # Create new docs directory
#        mkdir -p docs
#
#        # Copy new HTML documentation to docs folder
#        echo "Copying documentation files to docs folder..."
#        cp -r "$(Agent.BuildDirectory)/qdk-chemistry/docs/build/html/"* docs/
#
#        # Add .nojekyll file to docs folder to disable Jekyll processing
#        touch docs/.nojekyll
#        echo "Created .nojekyll file in docs folder"
#
#        # Stage all changes
#        git add .
#
#        # Check if there are changes to commit
#        if git diff --staged --quiet; then
#          echo "No changes detected in documentation"
#        else
#          echo "Changes detected, committing and pushing..."
#
#          # Create commit message with build information
#          COMMIT_MSG="Update documentation from pipeline $(Build.BuildNumber)\n\nDocumentation updated in docs/ folder\nBuilt from commit: $(Build.SourceVersion)\nSource branch: $(Build.SourceBranch)\nBuild date: $(date -u '+%Y-%m-%d %H:%M:%S UTC')\n\nPipeline: $(Build.DefinitionName)\nBuild reason: $(Build.Reason)"
#
#          git commit -m "$(echo -e "$COMMIT_MSG")"
#
#          # Push with retry logic
#          for i in 1 2 3; do
#            echo "Push attempt $i/3..."
#            if git push origin ${{ parameters.docsBranch }}; then
#              echo "Documentation successfully pushed to repository"
#              echo "Documentation is now available in the docs/ folder"
#              echo "If GitHub Pages is enabled, it will be available at the configured URL"
#              break
#            else
#              echo "Push failed, retrying in 5 seconds..."
#              sleep 5
#              if [ $i -eq 3 ]; then
#                echo "ERROR: Failed to push documentation after 3 attempts"
#                exit 1
#              fi
#            fi
#          done
#        fi
#
#        # Cleanup
#        rm -rf "$DOC_REPO_DIR"
#
#        # Clean up SSH key for security
#        rm -f ~/.ssh/id_rsa
#
#        echo "Documentation deployment completed successfully"
#        echo "Documentation structure in repository:"
#        echo "  docs/"
#        echo "    index.html (main documentation page)"
#        echo "    .nojekyll (GitHub Pages compatibility)"
#        echo "    ... (other documentation files)"
#      displayName: Deploy Documentation to Repository
#      condition: and(eq(variables['Build.SourceBranch'], 'refs/heads/main'), ne('${{ parameters.skipDocsDeployment }}', true))
